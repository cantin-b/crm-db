-- ================================
-- Migration: Prospect Tasks (Todo)
-- Adds:
--  - enum public.task_priority_enum  (LOW / MEDIUM / HIGH)
--  - table public.prospect_tasks     (date + priority + note + status)
--  - trigger set_updated_at on prospect_tasks
--  - helpful indexes for /tasks (today/future/past) + sorting by priority
-- ================================

BEGIN;

-- 1) Enum priorité
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_type t
    JOIN pg_namespace n ON n.oid = t.typnamespace
    WHERE n.nspname = 'public'
      AND t.typname = 'task_priority_enum'
  ) THEN
    CREATE TYPE public.task_priority_enum AS ENUM ('LOW', 'MEDIUM', 'HIGH');
  END IF;
END$$;

-- 2) Table tasks
CREATE TABLE IF NOT EXISTS public.prospect_tasks (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  prospect_id uuid NOT NULL REFERENCES public.prospects(id) ON DELETE CASCADE,

  -- date en heure de Paris (la conversion est gérée côté front comme pour reminders)
  task_date date NOT NULL,

  -- priorité triée : HIGH > MEDIUM > LOW (géré côté front / ORDER BY)
  priority public.task_priority_enum NOT NULL DEFAULT 'MEDIUM',

  note text,

  -- on réutilise le même enum que reminders pour éviter de multiplier les enums
  status public.reminder_status_enum NOT NULL DEFAULT 'PLANNED',

  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  created_by uuid REFERENCES public.profiles(id),
  completed_at timestamptz,

  -- compteur de replanification (si tu veux la même UX que reminders)
  reschedule_count integer NOT NULL DEFAULT 0
);

-- 3) Trigger updated_at (même pattern que prospect_reminders)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_trigger
    WHERE tgname = 'set_updated_at'
      AND tgrelid = 'public.prospect_tasks'::regclass
  ) THEN
    CREATE TRIGGER set_updated_at
    BEFORE UPDATE ON public.prospect_tasks
    FOR EACH ROW
    EXECUTE FUNCTION public.set_updated_at();
  END IF;
END$$;

-- 4) Indexes pour page /tasks (range today/future/past + tri par priorité)
-- Filtre principal: status + date
CREATE INDEX IF NOT EXISTS idx_prospect_tasks_status_date
  ON public.prospect_tasks (status, task_date);

-- Pour récupérer les tasks d’un prospect (fiche prospect)
CREATE INDEX IF NOT EXISTS idx_prospect_tasks_prospect
  ON public.prospect_tasks (prospect_id);

-- Tri courant recommandé: task_date ASC, priority DESC (et id pour stabilité)
-- (utile quand tu fais des pages type today/future)
CREATE INDEX IF NOT EXISTS idx_prospect_tasks_date_priority
  ON public.prospect_tasks (task_date, priority, id);

COMMIT;